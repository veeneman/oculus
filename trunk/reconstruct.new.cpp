#include "compress.h"
void parseLine(char* line, int& flag, int* field)
{
  int i;
  int tab_count = 0;
  flag = 0;
  for(i = 0;line[i] != 0; i++) //iterate through entire SAM line
  {
    if(line[i] == '\t')
    {
      tab_count++;
      field[tab_count] = i;

      if(tab_count == 10) //end of sequence field
      {
        i++;
        break;
      }
    }
    else if(tab_count == 1) //flag field
    {
      flag *= 10;
      flag += (line[i] - 48);
    }
  }
  for( ;line[i] != 0; i++) //find end of last field
  {
    if(line[i] == '\t' || line[i] == ' ' || line[i] == '\n')
    {
      tab_count++;
      field[tab_count] = i;
      break;
    }
  }
  if(tab_count != 11) //didn't pull the sequence correctly.
  {
    cerr << "SAM output from aligner is broken.\n";
    exit(1);
  }
}
void parseIDLine(char* line, int* field, int expected)
{
  int i;
  int tab_count = 0;
  for(i = 0;line[i] != 0; i++) //iterate through entire ID line
  {
    if(line[i] == '\t')
    {
      tab_count++;
      field[tab_count] = i;

      if(tab_count == (expected - 1)) //end of second to last field
      {
        i++;
        break;
      }
    }
  }
  for( ;line[i] != 0; i++) //find end of last field
  {
    if(line[i] == '\t' || line[i] == ' ' || line[i] == '\n')
    {
      tab_count++;
      field[tab_count] = i;
      break;
    }
  }
}

// This and compressInput are the two most conceptually important functions in oculus.
//  Using the map generated by compressInput, and the SAM results of the
//  aligner, it rebuilds the results of the sequence reads that were removed.

void reconstruct(ifstream& alignments,ofstream& recon, ifstream& ids,
		 bool SE_mode,bool fQ_mode,
		 bool base4_mode, bool RC_mode, bool qual_mode,
		 MAP& multi_map,NMAP& multi_nmap)
{
  //variables
  int i;
  char line1[MLS];
  char line2[MLS];
  int flag1;
  int flag2;
  int tabs1[12];
  int tabs2[12];
  int id_tabs[4];
  int forward_count;
  int reverse_count;
  char id_line[MLS];
  char seq1[MLS];
  char seq2[MLS];
  char name1[MLS];
  char name2[MLS];
  char qual1[MLS];
  char qual2[MLS];
  char linechunk[MLS];
  char lookup_seq[MLS*2];
  unsigned char lookup_key[MLS*2];
  MAP::iterator key_lookup_mh;
  NMAP::iterator key_lookup_nmh;
  bool reversed = false;
  char reverse_line[MLS];
  char reverse_seq[MLS];
  int expected_id_fields;
  bool rc1;
  bool rc2;
  if(qual_mode)
  {
    if(SE_mode && !fQ_mode){ expected_id_fields = 2; }
    else if(SE_mode && fQ_mode){ expected_id_fields = 3; }
    else if(!SE_mode && !fQ_mode){ expected_id_fields = 3; }
    else { expected_id_fields = 5; }
  }
  line1[0] = 0;
  line2[0] = 0;
  id_line[0] = 0;
  
  while(alignments.good()) //parse through compressed SAM file
  {
    alignments.getline(line1,MLS);

    if(line1[0] == 0) { break; } //sometimes files just end with empty lines
    else if(line1[0] == '@') { recon << line1 << "\n"; continue; } //header line - skip it
    if(!qual_mode) { recon << line1 << "\n"; } //print a copy of the line

    if(!SE_mode)
    {
      if(!alignments.good())
      {
        cerr << "Error: Couldn't read a pair from the SAM output.\n";
        exit(1);
      }

      alignments.getline(line2,MLS);

      if(line2[0] == 0) //this technically should never happen, but to be safe
      {
        cerr << "Error: Couldn't read a pair from the SAM output.\n";
        exit(1);
      }

      if(!qual_mode) { recon << line2 << "\n"; } //print a copy of the line
    }

    parseLine(line1,flag1,tabs1);
    if(!SE_mode) { parseLine(line2,flag2,tabs2); }

    lookup_seq[0] = 0;
    if(SE_mode)
    {
      if(RC_mode)
      {
        //passes in a string pointer, a destination, a length,
        // and a boolean indicating whether reversing was necessary
        oneWayRC(line1 + (tabs1[9] + 1), lookup_seq, tabs1[10] - (tabs1[9] + 1), reversed);

        if(!reversed) //just copy sequence to lookup_seq
        {
          lookup_seq[0] = 0;
          strncat(lookup_seq,line1 + (tabs1[9] + 1),tabs1[10] - (tabs1[9] + 1));
        }
      }
      else // !RC_mode
      {
        if((int)((flag1 % 32) / 16) == 1) //first is reversed
        {
          reverseComplement(line1 + (tabs1[9] + 1), lookup_seq,tabs1[10] - (tabs1[9] + 1));
          reversed=true;
        }
        else
        {
          strncat(lookup_seq,line1 + (tabs1[9] + 1),tabs1[10] - (tabs1[9] + 1));
          reversed=false;
        }
      }
    }
    else //paired end
    {
      seq1[0] = 0;
      seq2[0] = 0;

      if((int)((flag1 % 32) / 16) == 1) //first is reversed
      {
        reverseComplement(line1 + (tabs1[9] + 1), seq1,tabs1[10] - (tabs1[9] + 1));
        rc1 = true;
      }
      else //it isn't reversed
      {
        strncat(seq1,line1 + (tabs1[9] + 1),tabs1[10] - (tabs1[9] + 1));
        rc1 = false;
      }
      if((int)((flag2 % 32) / 16) == 1) //second is reversed
      {
        reverseComplement(line2 + (tabs2[9] + 1), seq2,tabs2[10] - (tabs2[9] + 1));
        rc2 = true;
      }
      else //it isn't reversed
      {
        strncat(seq2,line2 + (tabs2[9] + 1),tabs2[10] - (tabs2[9] + 1));
        rc2 = false;
      }

      if(RC_mode)
      {
        if(strncmp(seq1,seq2,MLS) > 0) //reverse order
        {
          reversed = true;
          strncat(lookup_seq,seq2,MLS);
          strncat(lookup_seq,seq1,MLS);
        }
        else //forward order
        {
          reversed = false;
          strncat(lookup_seq,seq1,MLS);
          strncat(lookup_seq,seq2,MLS);
        }

        if(((int)((flag1 % 256) / 128) == 1) && ((int)((flag2 % 128) / 64) == 1))
        //the reads were reversed in the alignment step
        {
          reversed = !reversed;
        }
      }
      else //the read order is correct (wrt input), go by flag only
      {
        if(((int)((flag1 % 256) / 128) == 1) && ((int)((flag2 % 128) / 64) == 1))
        //the reads were reversed in the alignment step
        {
          strncat(lookup_seq,seq2,MLS);
          strncat(lookup_seq,seq1,MLS);
          reversed = true;
        }
        else
        {
          strncat(lookup_seq,seq1,MLS);
          strncat(lookup_seq,seq2,MLS);
          reversed = false;
        }
      }
    }

    base4_mode ? compressSequence4(lookup_seq,lookup_key) : compressSequence(lookup_seq,lookup_key);

    if(SE_mode) //generate reverse copies of the flag.  won't necessarily use them.
    {
      if((int)((flag1 % 32) / 16) == 1)
      {
        flag1 -= 16;
        reversed = !reversed;
      }
      else
      {
        flag1 += 16;
      }
    }
    else
    {
      if((int)((flag1 % 256) / 128) == 1)
      {
        flag1 -= 64;
        flag2 += 64;
      }
      else
      {
        flag1 += 64;
        flag2 -= 64;
      }
    }

    if(!qual_mode)
    {
      key_lookup_mh = multi_map.find(lookup_key);
      if(key_lookup_mh != multi_map.end())
      {
        if(!reversed)
        {
          forward_count = (key_lookup_mh->second).first;
          reverse_count = (key_lookup_mh->second).second;
        }
        else
        {
          forward_count = (key_lookup_mh->second).second;
          reverse_count = (key_lookup_mh->second).first;
        }

        for(i = 0; i < forward_count; i++) //print forward hash entries in same orientation
        {
          recon << line1 << "\n";
          if(!SE_mode)
          {
            recon << line2 << "\n";
          }
        }
        for(i = 0; i < reverse_count; i++) //and reverse hash entries in opposite orientation
        {
          // 'Opposite orientation' here is interesting - it means both with a changed flag,
          // and in SE potentially a reversed sequence, and in PE potentially a reversed order.
          // The issue stems from bowtie outputting reads in their original orientation if they map to nothing.

          reverse_line[0] = 0;

          if(!SE_mode && (((flag1 % 8) / 4) == 1)) // surprise! - for unmapped reverse entries of PE, they should be printed in opposite order
          //it may also be necessary to check the second flag, XXX, though this seems unlikely - i think either both map or neither do
          {
            strncat(reverse_line,line2,tabs2[1] + 1);
            recon << reverse_line << flag2 << line2 + tabs2[2] << "\n";
            reverse_line[0] = 0;
            strncat(reverse_line,line1,tabs1[1] + 1);
            recon << reverse_line << flag1 << line1 + tabs1[2] << "\n";
          }
          else if(!SE_mode) //regular old PE
          {
            strncat(reverse_line,line1,tabs1[1] + 1);
            recon << reverse_line << flag1 << line1 + tabs1[2] << "\n";
            reverse_line[0] = 0;
            strncat(reverse_line,line2,tabs2[1] + 1);
            recon << reverse_line << flag2 << line2 + tabs2[2] << "\n";
          }
          else if(((flag1 % 8) / 4) == 1) //if it's unmapped, reverse the sequence, not the flag (SE)
          {
            strncat(reverse_line,line1,(tabs1[9] + 1));
            reverseComplement(line1 + (tabs1[9] + 1), reverse_seq, tabs1[10] - (tabs1[9] + 1));
            recon << reverse_line << reverse_seq << line1 + tabs1[10] << "\n";
          }
          else //reverse the flag (SE, and mapped)
          {
            strncat(reverse_line,line1,tabs1[1] + 1);
            recon << reverse_line << flag1 << line1 + tabs1[2] << "\n";
          }
        }
      }
    }
    else //qual_mode
    {
      key_lookup_nmh = multi_nmap.find(lookup_key);
      if(key_lookup_nmh != multi_nmap.end())
      {
        if(!reversed)
        {
          forward_count = (key_lookup_nmh->second).forward;
          reverse_count = (key_lookup_nmh->second).reverse;
        }
        else
        {
          forward_count = (key_lookup_nmh->second).reverse;
          reverse_count = (key_lookup_nmh->second).forward;
        }

        for(i = 0; i < forward_count + 1; i++) //print forward hash entries in same orientation
        {
          ids.getline(id_line,MLS); // this works
          parseIDLine(id_line,id_tabs,expected_id_fields);

          if(fQ_mode)
          {
            linechunk[0] = 0; name1[0] = 0; qual1[0] = 0;
            strncat(linechunk,line1 + tabs1[1],tabs1[10] - tabs1[1]);
            strncat(name1,id_line + id_tabs[1] + 1, id_tabs[2] - (id_tabs[1] + 1));
            if(reversed && !SE_mode)
            {
              strncat(qual1,id_line + (id_tabs[4] + 1), id_tabs[5] - (id_tabs[4] + 1));
              if(rc2) { reverseOrder(qual1,strlen(qual1));}
            }
            else
            {
              strncat(qual1,id_line + (id_tabs[2] + 1), id_tabs[3] - (id_tabs[2] + 1));
              if(rc1) { reverseOrder(qual1,strlen(qual1));}
            }
            recon << name1 << linechunk << "\t" << qual1 << line1 + tabs1[11] << "\n";
          }
          else
          {
            name1[0] = 0;
            strncat(name1,id_line + id_tabs[1] + 1, id_tabs[2] - (id_tabs[1] + 1));
            recon << name1 << line1 + tabs1[1] << "\n";
          }

          if(!SE_mode && fQ_mode)
          {
            linechunk[0] = 0; name2[0] = 0; qual2[0] = 0;
            strncat(linechunk,line2 + tabs2[1],tabs2[10] - tabs2[1]);
            strncat(name2,id_line + id_tabs[3] + 1, id_tabs[4] - (id_tabs[3] + 1));
            if(reversed && !SE_mode)
            {
              strncat(qual2,id_line + id_tabs[2], id_tabs[3] - id_tabs[2]);
              if(rc1) { reverseOrder(qual2,strlen(qual2)); }
            }
            else
            {
              strncat(qual2,id_line + id_tabs[4], id_tabs[5] - id_tabs[4]);
              if(rc2) { reverseOrder(qual2,strlen(qual2)); }
            }

            recon << name2 << linechunk << qual2 << line2 + tabs2[11] << "\n";
          }
          else
          {
            name2[0] = 0;
            strncat(name2,id_line + id_tabs[2] + 1, id_tabs[3] - (id_tabs[2] + 1));
            recon << name2 << line2 + tabs2[1] << "\n";
          }
        }
        for(i = 0; i < reverse_count; i++) //and reverse hash entries in opposite orientation
        {
          ids.getline(id_line,MLS); // this works
          parseIDLine(id_line,id_tabs,expected_id_fields);

          // 'Opposite orientation' here is interesting - it means both with a changed flag,
          // and in SE potentially a reversed sequence, and in PE potentially a reversed order.
          // The issue stems from bowtie outputting reads in their original orientation if they map to nothing.

          reverse_line[0] = 0;

          if(!SE_mode && (((flag1 % 8) / 4) == 1)) // surprise! - for unmapped reverse entries of PE, they should be printed in opposite order
          //it may also be necessary to check the second flag, XXX, though this seems unlikely - i think either both map or neither do
          {
            strncat(reverse_line,line2,tabs2[1] + 1);
            recon << reverse_line << flag2 << line2 + tabs2[2] << "\n";
            reverse_line[0] = 0;
            strncat(reverse_line,line1,tabs1[1] + 1);
            recon << reverse_line << flag1 << line1 + tabs1[2] << "\n";
          }
          else if(!SE_mode) //regular old PE
          {
            strncat(reverse_line,line1,tabs1[1] + 1);
            recon << reverse_line << flag1 << line1 + tabs1[2] << "\n";
            reverse_line[0] = 0;
            strncat(reverse_line,line2,tabs2[1] + 1);
            recon << reverse_line << flag2 << line2 + tabs2[2] << "\n";
          }
          else if(((flag1 % 8) / 4) == 1) //if it's unmapped, reverse the sequence, not the flag (SE)
          {
            strncat(reverse_line,line1,(tabs1[9] + 1));
            reverseComplement(line1 + (tabs1[9] + 1), reverse_seq, tabs1[10] - (tabs1[9] + 1));
            recon << reverse_line << reverse_seq << line1 + tabs1[10] << "\n";
          }
          else //reverse the flag (SE, and mapped)
          {
            strncat(reverse_line,line1,tabs1[1] + 1);
            recon << reverse_line << flag1 << line1 + tabs1[2] << "\n";
          }
        }
      }
    }
  }
}

