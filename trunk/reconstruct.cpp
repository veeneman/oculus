#include "compress.h"

// This and compressInput are the two most conceptually important functions in oculus.
//  Using the map generated by compressInput, and the SAM results of the
//  aligner, it rebuilds the results of the sequence reads that were removed.

void reconstruct(ifstream& alignments,ofstream& recon,
		 bool SE_mode,bool fQ_mode,
		 bool base4_mode, bool RC_mode,
		 MAP& multi_map)
{
  //variables
  int i;
  int tab_count;
  int seqstart_1;
  int seqstart_2;
  int seqend_1;
  int seqend_2;
  int flagstart_1;
  int flagstart_2;
  int flagend_1;
  int flagend_2;
  int flag1;
  int flag2;
  int forward_count;
  int reverse_count;
  char line1[MLS];
  char line2[MLS];
  char seq1[MLS];
  char seq2[MLS];
  char lookup_seq[MLS*2];
  unsigned char lookup_key[MLS*2];
  MAP::iterator key_lookup;
  bool reversed = false;
  char reverse_line[MLS];
  char reverse_seq[MLS];
  
  while(alignments.good())
    {
      //////////////////////////////////////////////////////////////////////////
      // File IO - Load SAM lines into memory and check stuff                 //
      //////////////////////////////////////////////////////////////////////////
      
      //get a line from the first file and print a copy of it
      alignments.getline(line1,MLS);
      if(line1[0] == 0) //sometimes files just end with empty lines
	{
	  break;
	}

      recon << line1 << "\n"; //print a copy of the line

      if(line1[0] == '@') //header line
	{
	  continue;
	}
      
      if(!SE_mode)
	{
	  if(!alignments.good())
	    {
	      cerr << "Error: Couldn't read a pair from the SAM output.\n";
	      exit(1);
	    }

	  alignments.getline(line2,MLS);

	  if(line2[0] == 0) //this technically should never happen, but to be safe
	    {
	      cerr << "Error: Couldn't read a pair from the SAM output.\n";
	      exit(1);
	    }

	  recon << line2 << "\n"; //print a copy of the line
	}
      
      //////////////////////////////////////////////////////////////////////////
      //  Sequence line parsing - record positions of sequence info, and      //
      //   retrieve the flag.                                                 //
      //////////////////////////////////////////////////////////////////////////
      
      tab_count = 0;
      flag1 = 0;
      for(i = 0;line1[i] != 0; i++) //iterate through entire SAM line
	{
	  if(line1[i] == '\t')
	    {
	      tab_count++;

	      if(tab_count == 1) //flag field
		{
		  flagstart_1 = i + 1;
		}
	      else if(tab_count == 2) //end of flag field
		{
		  flagend_1 = i;
		}
	      else if(tab_count == 9) //sequence field
		{
		  seqstart_1 = i+1;
		}
	      else if(tab_count == 10) //end of sequence field
		{
		  seqend_1 = i;
		  break;
		}
	    }
	  else if(tab_count == 1) //its a character in the flag field
	    {
	      flag1 *= 10;
	      flag1 += (line1[i] - 48); // - '0'
	    }
	}
      if(tab_count != 10) //didn't pull the sequence correctly.
	{
	  cerr << "SAM output from aligner is broken.\n";
	  exit(1);
	}
      
      //same thing, for the second line
      if(!SE_mode)
	{
	  tab_count = 0;
	  flag2 = 0;
	  for(i = 0;line2[i] != 0; i++) //iterate through entire second SAM line
	    {
	      if(line2[i] == '\t')
		{
		  tab_count++;
		  
		  if(tab_count == 1) //flag
		    {
		      flagstart_2 = i + 1;
		    }
		  else if(tab_count == 2) // endflag
		    {
		      flagend_2 = i;
		    }
		  else if(tab_count == 9) //sequence
		    {
		      seqstart_2 = i + 1;
		    }
		  else if(tab_count == 10) //end of sequence
		    {
		      seqend_2 = i;
		      break;
		    }
		}
	      else if(tab_count == 1)
		{
		  flag2 *= 10;
		  flag2 += (line2[i] - 48);
		}
	    }
	  if(tab_count != 10)
	    {
	      cerr << "SAM output from aligner is broken.\n";
	      exit(1);
	    }
	}

      //////////////////////////////////////////////////////////////////////////
      //  Generate the lookup sequence to check against the map               //
      //////////////////////////////////////////////////////////////////////////
      
      lookup_seq[0] = 0;
      if(SE_mode)
	{
	  if(RC_mode)
	    {
	      //passes in a string pointer, a destination, a length,
	      // and a boolean indicating whether reversing was necessary
	      oneWayRC(line1 + seqstart_1, lookup_seq, seqend_1 - seqstart_1, reversed);
	      
	      if(!reversed) //just copy sequence to lookup_seq
		{
		  lookup_seq[0] = 0;
		  strncat(lookup_seq,line1 + seqstart_1,seqend_1 - seqstart_1);
		}
	    }
	  else
	    {
	      if((int)((flag1 % 32) / 16) == 1) //first is reversed
		{
		  reverseComplement(line1 + seqstart_1, lookup_seq,seqend_1 - seqstart_1);
		  reversed=true;
		}
	      else
		{
		  strncat(lookup_seq,line1 + seqstart_1,seqend_1 - seqstart_1);
		  reversed=false;
		}
	    }
	}
      else //paired end
	{
	  seq1[0] = 0;
	  seq2[0] = 0;

	  if((int)((flag1 % 32) / 16) == 1) //first is reversed
	    {
	      reverseComplement(line1 + seqstart_1, seq1,seqend_1 - seqstart_1);
	    }
	  else //it isn't reversed
	    {
	      strncat(seq1,line1 + seqstart_1,seqend_1 - seqstart_1);
	    }
	  if((int)((flag2 % 32) / 16) == 1) //second is reversed
	    {
	      reverseComplement(line2 + seqstart_2, seq2,seqend_2 - seqstart_2);
	    }
	  else //it isn't reversed
	    {
	      strncat(seq2,line2 + seqstart_2,seqend_2 - seqstart_2);
	    }

	  if(RC_mode)
	    {
	      if(strncmp(seq1,seq2,MLS) > 0) //reverse order
		{
		  reversed = true;
		  strncat(lookup_seq,seq2,MLS);
		  strncat(lookup_seq,seq1,MLS);
		}
	      else //forward order
		{
		  reversed = false;
		  strncat(lookup_seq,seq1,MLS);
		  strncat(lookup_seq,seq2,MLS);
		}
	      
	      if(((int)((flag1 % 256) / 128) == 1) && ((int)((flag2 % 128) / 64) == 1))
		//the reads were reversed in the alignment step
		{
		  reversed = !reversed;
		}
	    }
	  else //the read order is correct (wrt input), go by flag only
	    {
	      if(((int)((flag1 % 256) / 128) == 1) && ((int)((flag2 % 128) / 64) == 1))
		//the reads were reversed in the alignment step
		{
		  strncat(lookup_seq,seq2,MLS);
		  strncat(lookup_seq,seq1,MLS);
		}
	      else
		{
		  strncat(lookup_seq,seq1,MLS);
		  strncat(lookup_seq,seq2,MLS);
		}
	    }
	}

      base4_mode ? compressSequence4(lookup_seq,lookup_key) : compressSequence(lookup_seq,lookup_key);

      if(SE_mode) //generate reverse copies of the flag.  won't necessarily use them.
	{
	  if((int)((flag1 % 32) / 16) == 1)
	    {
	      flag1 -= 16;
	      reversed = !reversed;
	    }
	  else
	    {
	      flag1 += 16;
	    }
	}
      else
	{
	  if((int)((flag1 % 256) / 128) == 1)
	    {
	      flag1 -= 64;
	      flag2 += 64;
	    }
	  else
	    {
	      flag1 += 64;
	      flag2 -= 64;
	    }
	}
      
      key_lookup = multi_map.find(lookup_key);
      if(key_lookup != multi_map.end())
	{
	  if(!reversed)
	    {
	      forward_count = (key_lookup->second).first;
	      reverse_count = (key_lookup->second).second;
	    }
	  else
	    {
	      forward_count = (key_lookup->second).second;
	      reverse_count = (key_lookup->second).first;
	    }

	  for(i = 0; i < forward_count; i++) //print forward hash entries in same orientation
	    {
	      recon << line1 << "\n";
	      if(!SE_mode)
		{
		  recon << line2 << "\n";
		}
	    }
	  for(i = 0; i < reverse_count; i++) //and reverse hash entries in opposite orientation
	    {
	      // 'Opposite orientation' here is interesting - it means both with a changed flag,
	      // and in SE potentially a reversed sequence, and in PE potentially a reversed order.
	      // The issue stems from bowtie outputting reads in their original orientation if they map to nothing.

	      reverse_line[0] = 0;

	      if(!SE_mode && (((flag1 % 8) / 4) == 1)) // surprise! - for unmapped reverse entries of PE, they should be printed in opposite order
		//it may also be necessary to check the second flag, XXX, though this seems unlikely - i think either both map or neither do
		{
		  strncat(reverse_line,line2,flagstart_2);
		  recon << reverse_line << flag2 << line2 + flagend_2 << "\n";
		  reverse_line[0] = 0;
		  strncat(reverse_line,line1,flagstart_1);
		  recon << reverse_line << flag1 << line1 + flagend_1 << "\n";
		}
	      else if(!SE_mode) //regular old PE
		{
		  strncat(reverse_line,line1,flagstart_1);
		  recon << reverse_line << flag1 << line1 + flagend_1 << "\n";
		  reverse_line[0] = 0;
		  strncat(reverse_line,line2,flagstart_2);
		  recon << reverse_line << flag2 << line2 + flagend_2 << "\n";		  
		}
	      else if(((flag1 % 8) / 4) == 1) //if it's unmapped, reverse the sequence, not the flag (SE)
		{
		  strncat(reverse_line,line1,seqstart_1);
		  reverseComplement(line1 + seqstart_1, reverse_seq, seqend_1 - seqstart_1);
		  recon << reverse_line << reverse_seq << line1 + seqend_1 << "\n";
		}
	      else //reverse the flag (SE, and mapped)
		{
		  strncat(reverse_line,line1,flagstart_1);
		  recon << reverse_line << flag1 << line1 + flagend_1 << "\n";
		}
	    }
	}
    }
}

